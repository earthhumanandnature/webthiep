<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Thi·ªáp ‚Äì B·∫•m v√†o Tr√°i ƒê·∫•t nh√©!</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; touch-action:none; }
    #info { position:absolute; top:10px; left:10px; color:#fff; padding:10px 15px;
            background:rgba(0,0,0,0.7); border-radius:8px; font-family:Arial;
            pointer-events:none; z-index:100; font-size:14px; }
    #flash { position:fixed; top:0; left:0; width:100%; height:100%; background:#fff; opacity:0;
              pointer-events:none; transition:opacity 2.8s ease-out; z-index:9998; }
    #card {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%) scale(0);
      width:90%; max-width:520px; padding:40px 20px; box-sizing:border-box;
      background:linear-gradient(135deg,#120428,#0c1e3d);
      color:#fff; text-align:center; font-family:'Segoe UI',Arial,sans-serif;
      border-radius:25px; box-shadow:0 0 80px rgba(0,255,255,0.6);
      border:4px solid rgba(0,255,255,0.7); z-index:9999; opacity:0;
      transition:all 1.8s cubic-bezier(0.25,0.8,0.25,1);
    }
    #card.show { transform:translate(-50%,-50%) scale(1); opacity:1; }
    #card h1 { font-size:42px; margin:0 0 20px;
               background:linear-gradient(90deg,#00ffff,#ff00ff);
               -webkit-background-clip:text; color:transparent; }
    #card p { font-size:20px; line-height:1.6; margin:15px 0; }
  </style>
</head>
<body>
  <div id="info">Ch·∫°m ho·∫∑c b·∫•m v√†o Tr√°i ƒê·∫•t ƒë·ªÉ m·ªü thi·ªáp b√≠ m·∫≠t! ‚ú®</div>
  <div id="flash"></div>
  <div id="card">
    <h1>Ch√∫c M·ª´ng Ng√†y Ph·ª• N·ªØ Vi·ªát Nam 20/11! ‚ú®</h1>
    <p>Ch√∫c ch·ªã ng√†y 20/11 th·∫≠t nhi·ªÅu ni·ªÅm vui,<br>s·ª©c kh·ªèe d·ªìi d√†o, h·∫°nh ph√∫c ng·∫≠p tr√†n! ( d√π h√¥m nay l√† 20/11 =)) ) üíñüíñ</p>
    <p style="margin-top:40px; color:#00ffff; font-size:18px;">T·ª´ ... üëãüëã</p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // ============== C∆† B·∫¢N ==============
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 12000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    camera.position.set(0, 600, 1800);

    // ============== N·ªÄN V≈® TR·ª§ ==============
    const starGeo = new THREE.BufferGeometry();
    const vertices = [];
    for(let i=0;i<40000;i++) vertices.push(THREE.MathUtils.randFloatSpread(10000),THREE.MathUtils.randFloatSpread(10000),THREE.MathUtils.randFloatSpread(10000));
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices,3));
    scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff,size:1.6,sizeAttenuation:true,transparent:true,opacity:0.9})));

    const nebulaGroup = new THREE.Group(); scene.add(nebulaGroup);
    for(let l=0;l<3;l++){
      const size = 2500 + l*1000;
      const mat = new THREE.ShaderMaterial({
        uniforms:{time:{value:0},layer:{value:l}},
        vertexShader:`varying vec3 vPos;void main(){vPos=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader:`
          uniform float time;uniform float layer;varying vec3 vPos;
          float hash(vec3 p){return fract(sin(dot(p,vec3(7,157,113)))*43758.5453);}
          float noise(vec3 p){vec3 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
            return mix(mix(mix(hash(i),hash(i+vec3(1,0,0)),f.x),mix(hash(i+vec3(0,1,0)),hash(i+vec3(1,1,0)),f.x),f.y),
                       mix(mix(hash(i+vec3(0,0,1)),hash(i+vec3(1,0,1)),f.x),mix(hash(i+vec3(0,1,1)),hash(i+vec3(1,1,1)),f.x),f.y),f.z);}
          void main(){
            vec3 p=vPos*0.001+vec3(time*0.015);
            float n=noise(p+layer*10.)+noise(p*2.+layer*15.)*0.5+noise(p*4.)*0.25;n/=1.75;
            float d=smoothstep(0.35,0.7,n);
            vec3 c=layer<1.?vec3(.5,0,1):layer<2.?vec3(0,.7,1):vec3(1,.3,.8);
            gl_FragColor=vec4(c,d*0.22);
          }`,
        transparent:true,side:THREE.BackSide,depthWrite:false,blending:THREE.AdditiveBlending
      });
      const m=new THREE.Mesh(new THREE.SphereGeometry(size,80,80),mat);
      m.rotation.y=Math.random()*Math.PI*2;
      nebulaGroup.add(m);
    }

    // ============== M·∫∂T TR·ªúI ==============
    const sun = new THREE.Mesh(new THREE.SphereGeometry(70,64,64), new THREE.MeshBasicMaterial({color:0xffee88}));
    sun.add(new THREE.Mesh(new THREE.SphereGeometry(110,32,32), new THREE.MeshBasicMaterial({color:0xffaa00,transparent:true,opacity:0.6})));
    scene.add(sun);
    sun.add(new THREE.PointLight(0xffffff,3,6000));

    // ============== H·ªÜ M·∫∂T TR·ªúI + V·ªÜT S√ÅNG + M·∫∂T TRƒÇNG ==============
    const planetData = [
      {name:"Mercury",r:12,dist:180,color:0xcccccc,period:4},
      {name:"Venus",r:18,dist:280,color:0xffe4b5,period:8},
      {name:"Earth",r:20,dist:400,color:0x2288ff,period:12},
      {name:"Mars",r:14,dist:550,color:0xff4444,period:18},
      {name:"Jupiter",r:55,dist:900,color:0xf4a460,period:25},
      {name:"Saturn",r:48,dist:1300,color:0xd2b48c,period:28},
      {name:"Uranus",r:28,dist:1700,color:0x87ceeb,period:29},
      {name:"Neptune",r:27,dist:2100,color:0x4169e1,period:30}
    ];

    const trails = [];
    let earthMesh = null;

    planetData.forEach(p => {
      const planet = new THREE.Mesh(
        new THREE.SphereGeometry(p.r,32,32),
        new THREE.MeshStandardMaterial({color:p.color,emissive:p.color,emissiveIntensity:0.5})
      );
      const orbit = new THREE.Object3D();
      orbit.add(planet);
      planet.position.x = p.dist;
      scene.add(orbit);

      if(p.name==="Earth") earthMesh = planet;

      // V√≤ng ƒëai Saturn
      if(p.name==="Saturn"){
        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(p.r*1.7,p.r*0.4,16,120),
          new THREE.MeshBasicMaterial({color:0xdeb887,side:THREE.DoubleSide,transparent:true,opacity:0.9})
        );
        ring.rotation.x = Math.PI/2;
        planet.add(ring);
      }

      // V·ªát s√°ng h√†nh tinh
      const trail = new THREE.Line(new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({color:p.color,transparent:true,opacity:0.6,blending:THREE.AdditiveBlending}));
      scene.add(trail);
      trails.push({orbit,orbit,planet,trail,positions:[],maxPoints:500,period:p.period});

      // M·∫∑t TrƒÉng cho Tr√°i ƒê·∫•t
      if(p.name==="Earth"){
        const moon = new THREE.Mesh(
          new THREE.SphereGeometry(6,24,24),
          new THREE.MeshStandardMaterial({color:0xdddddd,emissive:0xdddddd,emissiveIntensity:0.3})
        );
        moon.position.x = 50;
        planet.add(moon);

        const moonTrail = new THREE.Line(new THREE.BufferGeometry(),
          new THREE.LineBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.5,blending:THREE.AdditiveBlending}));
        scene.add(moonTrail);
        trails.push({orbit:planet,planet:moon,trail:moonTrail,positions:[],maxPoints:300,period:2.5});
      }
    });

    // ============== SAO BƒÇNG ==============
    const shootingStars = [];
    function createShootingStar(){
      const points = []; for(let i=0;i<200;i++) points.push(new THREE.Vector3());
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.PointsMaterial({color:0xccffff,size:20,sizeAttenuation:true,transparent:true,blending:THREE.AdditiveBlending});
      const star = new THREE.Points(geo, mat);
      scene.add(star);
      const dir = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
      shootingStars.push({obj:star, pos:dir.clone().multiplyScalar(-5500), dir, speed:40+Math.random()*35, life:0, maxLife:160});
    }
    setInterval(()=>{ if(Math.random()<0.8) createShootingStar(); if(Math.random()<0.3) createShootingStar(); }, 3000+Math.random()*2000);

    // ============== B·∫§M/CH·∫†M V√ÄO TR√ÅI ƒê·∫§T (HO·∫†T ƒê·ªòNG C·∫¢ PC + ƒêI·ªÜN THO·∫†I) ==============
    let triggered = false;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onPointer(event) {
      if (triggered || !earthMesh) return;

      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;

      mouse.x = (clientX / innerWidth) * 2 - 1;
      mouse.y = -(clientY / innerHeight) * 2 +  + 1;

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(earthMesh, true);

      if (hits.length > 0) {
        triggered = true;
        document.getElementById('flash').style.opacity = 1;
        setTimeout(() => {
          document.getElementById('flash').style.opacity = 0;
          renderer.domElement.style.transition = 'opacity 1.5s';
          renderer.domElement.style.opacity = 0;
          document.getElementById('card').classList.add('show');
        }, 2800);
      }
    }

    window.addEventListener('click', onPointer);
    window.addEventListener('touchstart', onPointer);

    // ============== ANIMATION ==============
    function animate(){
      if(triggered) return;
      requestAnimationFrame(animate);

      // C·∫≠p nh·∫≠t v·ªát s√°ng
      trails.forEach(t => {
        t.orbit.rotation.y += (Math.PI*2)/(t.period*60);
        const pos = t.planet.getWorldPosition(new THREE.Vector3());
        t.positions.push(pos.x,pos.y,pos.z);
        if(t.positions.length > t.maxPoints*3) t.positions.splice(0,3);
        t.trail.geometry.setAttribute('position', new THREE.Float32BufferAttribute(t.positions,3));
      });

      // Sao bƒÉng
      for(let i=shootingStars.length-1; i>=0; i--){
        const s = shootingStars[i]; s.life++;
        const pos = s.obj.geometry.attributes.position.array;
        for(let j=0; j<pos.length; j+=3){
          const prog = j/3/(pos.length/3-1);
          const v = s.pos.clone().addScaledVector(s.dir, (s.life - prog*160)*s.speed);
          pos[j]=v.x; pos[j+1]=v.y; pos[j+2]=v.z;
        }
        s.obj.geometry.attributes.position.needsUpdate = true;
        s.obj.material.opacity = Math.max(0, 1 - s.life/s.maxLife);
        if(s.life > s.maxLife){
          scene.remove(s.obj); s.obj.geometry.dispose(); s.obj.material.dispose();
          shootingStars.splice(i,1);
        }
      }

      sun.rotation.y += 0.006;
      nebulaGroup.children.forEach((n,i)=>{ n.material.uniforms.time.value=performance.now()*0.001; n.rotation.y+=0.00004*(i+1); });
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
